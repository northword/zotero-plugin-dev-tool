type PrefsMap = Map<string, string | number | boolean | undefined>;

export function parsePrefs(prefsContent: string): PrefsMap {
  // eslint-disable-next-line regexp/no-super-linear-backtracking
  const prefPattern = /^pref\s*\(\s*["']([^"']+)["']\s*,\s*(.+)\s*\)\s*;$/gm;
  const prefsMap: Map<string, string | boolean | number > = new Map();

  const matches = prefsContent.matchAll(prefPattern);
  for (const match of matches) {
    const key = match[1].trim();
    const value = match[2].trim();

    let parsedValue: string | boolean | number;
    if (value === "true" || value === "false") {
      parsedValue = value === "true";
    }
    else if (/^\d+$/.test(value)) {
      parsedValue = Number(value);
    }
    else {
      parsedValue = value.replace(/['"]/g, "");
    }

    if (prefsMap.has(key)) {
      // this.logger.warn(`Duplicate preference keys found: ${key}`);
    }
    else {
      prefsMap.set(key, parsedValue);
    }
  };

  return prefsMap;
}

export function renderDts(prefsMap: PrefsMap, prefix: string) {
  const dtsContent = `
/* prettier-ignore */
/* eslint-disable */
// @ts-nocheck
// Generated by zotero-plugin-scaffold

type _PluginPrefsMap = {
  ${Array.from(prefsMap)
    .map(pref => `"${pref[0].replace(prefix, "")}": ${typeof pref[1]};`)
    .join("\n  ")}
};

type PluginPrefKey<K extends keyof _PluginPrefsMap> = \`${prefix}\${K}\`;

type PluginPrefsMap = {
  [K in keyof _PluginPrefsMap as PluginPrefKey<K>]: _PluginPrefsMap[K]
};

declare namespace _ZoteroTypes {
  interface Prefs {
    get: <K extends keyof PluginPrefsMap>(key: K, global?: boolean) => PluginPrefsMap[K];
    set: <K extends keyof PluginPrefsMap>(key: K, value: PluginPrefsMap[K], global?: boolean) => any;
  }
}
`;

  return dtsContent;
}
